// SPDX-FileCopyrightText: 2020 Efabless Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// SPDX-License-Identifier: Apache-2.0

// gonsolo: Include Diffuse.v from pepe commit ba8e4

// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

module MulFullRawFN(	// <stdin>:3:10, :632:10, :1261:10
  input         io_a_isNaN,
                io_a_isInf,
                io_a_isZero,
                io_a_sign,
  input  [9:0]  io_a_sExp,
  input  [24:0] io_a_sig,
  output        io_invalidExc,
                io_rawOut_isNaN,
                io_rawOut_isInf,
                io_rawOut_isZero,
                io_rawOut_sign,
  output [9:0]  io_rawOut_sExp,
  output [47:0] io_rawOut_sig);

  assign io_invalidExc = io_a_isNaN & ~(io_a_sig[22]);	// <stdin>:3:10, :632:10, :1261:10, hardfloat/src/main/scala/common.scala:82:{46,49,56}
  assign io_rawOut_isNaN = io_a_isNaN;	// <stdin>:3:10, :632:10, :1261:10
  assign io_rawOut_isInf = io_a_isInf;	// <stdin>:3:10, :632:10, :1261:10
  assign io_rawOut_isZero = io_a_isZero;	// <stdin>:3:10, :632:10, :1261:10
  assign io_rawOut_sign = io_a_sign;	// <stdin>:3:10, :632:10, :1261:10
  assign io_rawOut_sExp = io_a_sExp - 10'h2;	// <stdin>:3:10, :632:10, :1261:10, hardfloat/src/main/scala/MulRecFN.scala:62:48
  assign io_rawOut_sig = {23'h0, io_a_sig} * 48'hA2F983;	// <stdin>:3:10, :632:10, :1261:10, hardfloat/src/main/scala/MulRecFN.scala:63:35
endmodule

module MulRawFN(	// <stdin>:37:10, :666:10, :1295:10
  input         io_a_isNaN,
                io_a_isInf,
                io_a_isZero,
                io_a_sign,
  input  [9:0]  io_a_sExp,
  input  [24:0] io_a_sig,
  output        io_invalidExc,
                io_rawOut_isNaN,
                io_rawOut_isInf,
                io_rawOut_isZero,
                io_rawOut_sign,
  output [9:0]  io_rawOut_sExp,
  output [26:0] io_rawOut_sig);

  wire [47:0] _mulFullRaw_io_rawOut_sig;	// hardfloat/src/main/scala/MulRecFN.scala:84:28
  MulFullRawFN mulFullRaw (	// hardfloat/src/main/scala/MulRecFN.scala:84:28
    .io_a_isNaN       (io_a_isNaN),
    .io_a_isInf       (io_a_isInf),
    .io_a_isZero      (io_a_isZero),
    .io_a_sign        (io_a_sign),
    .io_a_sExp        (io_a_sExp),
    .io_a_sig         (io_a_sig),
    .io_invalidExc    (io_invalidExc),
    .io_rawOut_isNaN  (io_rawOut_isNaN),
    .io_rawOut_isInf  (io_rawOut_isInf),
    .io_rawOut_isZero (io_rawOut_isZero),
    .io_rawOut_sign   (io_rawOut_sign),
    .io_rawOut_sExp   (io_rawOut_sExp),
    .io_rawOut_sig    (_mulFullRaw_io_rawOut_sig)
  );
  assign io_rawOut_sig =
    {_mulFullRaw_io_rawOut_sig[47:22], |(_mulFullRaw_io_rawOut_sig[21:0])};	// <stdin>:37:10, :666:10, :1295:10, hardfloat/src/main/scala/MulRecFN.scala:84:28, :93:{10,15,37,55}
endmodule

module RoundAnyRawFNToRecFN(	// <stdin>:61:10, :690:10, :1319:10
  input         io_invalidExc,
                io_in_isNaN,
                io_in_isInf,
                io_in_isZero,
                io_in_sign,
  input  [9:0]  io_in_sExp,
  input  [26:0] io_in_sig,
  output [32:0] io_out);

  wire [8:0]  _roundMask_T_1 = ~(io_in_sExp[8:0]);	// hardfloat/src/main/scala/RoundAnyRawFNToRecFN.scala:155:37, hardfloat/src/main/scala/primitives.scala:52:21
  wire [64:0] _GEN = {59'h0, _roundMask_T_1[5:0]};	// hardfloat/src/main/scala/primitives.scala:52:21, :59:26, :76:56
  wire [64:0] roundMask_shift = $signed(65'sh10000000000000000 >>> _GEN);	// hardfloat/src/main/scala/primitives.scala:76:56
  wire [64:0] roundMask_shift_1 = $signed(65'sh10000000000000000 >>> _GEN);	// hardfloat/src/main/scala/primitives.scala:76:56
  wire [24:0] _roundMask_T_74 =
    (_roundMask_T_1[8]
       ? (_roundMask_T_1[7]
            ? {~(_roundMask_T_1[6]
                   ? 22'h0
                   : ~{roundMask_shift[42],
                       roundMask_shift[43],
                       roundMask_shift[44],
                       roundMask_shift[45],
                       roundMask_shift[46],
                       roundMask_shift[47],
                       roundMask_shift[48],
                       roundMask_shift[49],
                       roundMask_shift[50],
                       roundMask_shift[51],
                       roundMask_shift[52],
                       roundMask_shift[53],
                       roundMask_shift[54],
                       roundMask_shift[55],
                       roundMask_shift[56],
                       roundMask_shift[57],
                       roundMask_shift[58],
                       roundMask_shift[59],
                       roundMask_shift[60],
                       roundMask_shift[61],
                       roundMask_shift[62],
                       roundMask_shift[63]}),
               3'h7}
            : {22'h0,
               _roundMask_T_1[6]
                 ? {roundMask_shift_1[0], roundMask_shift_1[1], roundMask_shift_1[2]}
                 : 3'h0})
       : 25'h0) | {24'h0, io_in_sig[26]};	// hardfloat/src/main/scala/RoundAnyRawFNToRecFN.scala:119:57, :158:23, hardfloat/src/main/scala/primitives.scala:52:21, :58:25, :59:26, :62:24, :67:24, :68:58, :73:{17,21,32}, :76:56, :77:20, :78:22
  wire [25:0] _GEN_0 = {_roundMask_T_74, 1'h1};	// hardfloat/src/main/scala/RoundAnyRawFNToRecFN.scala:158:{23,42}, :242:60
  wire [25:0] _GEN_1 = io_in_sig[26:1] & {1'h1, ~_roundMask_T_74} & _GEN_0;	// hardfloat/src/main/scala/RoundAnyRawFNToRecFN.scala:158:{23,42}, :161:53, :162:28, :163:40, :242:60
  wire [25:0] roundedSig =
    (|_GEN_1)
      ? {1'h0, io_in_sig[26:2] | _roundMask_T_74} + 26'h1
        & ~((|_GEN_1) & (io_in_sig[25:0] & _GEN_0) == 26'h0
              ? {_roundMask_T_74, 1'h1}
              : 26'h0)
      : {1'h0, io_in_sig[26:2] & ~_roundMask_T_74};	// hardfloat/src/main/scala/RoundAnyRawFNToRecFN.scala:57:16, :158:{23,42}, :162:28, :163:{40,56}, :164:{42,62}, :172:16, :173:{32,49,57}, :174:{21,25,64}, :176:35, :179:{30,47}, :180:24, :242:60
  wire [10:0] sRoundedExp = {io_in_sExp[9], io_in_sExp} + {9'h0, roundedSig[25:24]};	// hardfloat/src/main/scala/RoundAnyRawFNToRecFN.scala:172:16, :184:{40,54}, :272:16
  wire        common_totalUnderflow = $signed(sRoundedExp) < 11'sh6B;	// hardfloat/src/main/scala/RoundAnyRawFNToRecFN.scala:184:40, :199:31
  wire        isNaNOut = io_invalidExc | io_in_isNaN;	// hardfloat/src/main/scala/RoundAnyRawFNToRecFN.scala:234:34
  wire        notNaN_isInfOut =
    io_in_isInf | ~isNaNOut & ~io_in_isInf & ~io_in_isZero
    & $signed(sRoundedExp[10:7]) > 4'sh2;	// hardfloat/src/main/scala/RoundAnyRawFNToRecFN.scala:184:40, :195:{30,50}, :234:34, :236:{22,36,64}, :237:32, :247:32
  assign io_out =
    {~isNaNOut & io_in_sign,
     sRoundedExp[8:0] & ~(io_in_isZero | common_totalUnderflow ? 9'h1C0 : 9'h0)
       & {2'h3, ~notNaN_isInfOut, 6'h3F} | (notNaN_isInfOut ? 9'h180 : 9'h0)
       | (isNaNOut ? 9'h1C0 : 9'h0),
     isNaNOut | io_in_isZero | common_totalUnderflow
       ? {isNaNOut, 22'h0}
       : io_in_sig[26] ? roundedSig[23:1] : roundedSig[22:0]};	// <stdin>:61:10, :690:10, :1319:10, hardfloat/src/main/scala/RoundAnyRawFNToRecFN.scala:119:57, :158:42, :172:16, :184:40, :186:37, :188:16, :189:27, :190:27, :199:31, :234:34, :247:32, :249:22, :252:{14,18,32}, :263:17, :264:{14,18}, :272:16, :276:{16,73}, :277:16, :279:{12,38}, :280:16, :285:33, hardfloat/src/main/scala/primitives.scala:73:21
endmodule

module RoundRawFNToRecFN(	// <stdin>:309:10, :938:10, :1567:10
  input         io_invalidExc,
                io_in_isNaN,
                io_in_isInf,
                io_in_isZero,
                io_in_sign,
  input  [9:0]  io_in_sExp,
  input  [26:0] io_in_sig,
  output [32:0] io_out);

  RoundAnyRawFNToRecFN roundAnyRawFNToRecFN (	// hardfloat/src/main/scala/RoundAnyRawFNToRecFN.scala:308:15
    .io_invalidExc (io_invalidExc),
    .io_in_isNaN   (io_in_isNaN),
    .io_in_isInf   (io_in_isInf),
    .io_in_isZero  (io_in_isZero),
    .io_in_sign    (io_in_sign),
    .io_in_sExp    (io_in_sExp),
    .io_in_sig     (io_in_sig),
    .io_out        (io_out)
  );
endmodule

module MulRecFN(	// <stdin>:326:10, :955:10, :1584:10
  input  [32:0] io_a,
  output [32:0] io_out);

  wire        _mulRawFN_io_invalidExc;	// hardfloat/src/main/scala/MulRecFN.scala:113:26
  wire        _mulRawFN_io_rawOut_isNaN;	// hardfloat/src/main/scala/MulRecFN.scala:113:26
  wire        _mulRawFN_io_rawOut_isInf;	// hardfloat/src/main/scala/MulRecFN.scala:113:26
  wire        _mulRawFN_io_rawOut_isZero;	// hardfloat/src/main/scala/MulRecFN.scala:113:26
  wire        _mulRawFN_io_rawOut_sign;	// hardfloat/src/main/scala/MulRecFN.scala:113:26
  wire [9:0]  _mulRawFN_io_rawOut_sExp;	// hardfloat/src/main/scala/MulRecFN.scala:113:26
  wire [26:0] _mulRawFN_io_rawOut_sig;	// hardfloat/src/main/scala/MulRecFN.scala:113:26
  MulRawFN mulRawFN (	// hardfloat/src/main/scala/MulRecFN.scala:113:26
    .io_a_isNaN       ((&(io_a[31:30])) & io_a[29]),	// hardfloat/src/main/scala/rawFloatFromRecFN.scala:51:21, :53:{28,53}, :56:{33,41}
    .io_a_isInf       ((&(io_a[31:30])) & ~(io_a[29])),	// hardfloat/src/main/scala/rawFloatFromRecFN.scala:51:21, :53:{28,53}, :56:41, :57:{33,36}
    .io_a_isZero      (~(|(io_a[31:29]))),	// hardfloat/src/main/scala/rawFloatFromRecFN.scala:51:21, :52:{28,53}
    .io_a_sign        (io_a[32]),	// hardfloat/src/main/scala/rawFloatFromRecFN.scala:59:25
    .io_a_sExp        ({1'h0, io_a[31:23]}),	// hardfloat/src/main/scala/MulRecFN.scala:102:16, hardfloat/src/main/scala/rawFloatFromRecFN.scala:51:21, :60:27
    .io_a_sig         ({1'h0, |(io_a[31:29]), io_a[22:0]}),	// hardfloat/src/main/scala/MulRecFN.scala:102:16, hardfloat/src/main/scala/rawFloatFromRecFN.scala:51:21, :52:{28,53}, :61:{44,49}
    .io_invalidExc    (_mulRawFN_io_invalidExc),
    .io_rawOut_isNaN  (_mulRawFN_io_rawOut_isNaN),
    .io_rawOut_isInf  (_mulRawFN_io_rawOut_isInf),
    .io_rawOut_isZero (_mulRawFN_io_rawOut_isZero),
    .io_rawOut_sign   (_mulRawFN_io_rawOut_sign),
    .io_rawOut_sExp   (_mulRawFN_io_rawOut_sExp),
    .io_rawOut_sig    (_mulRawFN_io_rawOut_sig)
  );
  RoundRawFNToRecFN roundRawFNToRecFN (	// hardfloat/src/main/scala/MulRecFN.scala:121:15
    .io_invalidExc (_mulRawFN_io_invalidExc),	// hardfloat/src/main/scala/MulRecFN.scala:113:26
    .io_in_isNaN   (_mulRawFN_io_rawOut_isNaN),	// hardfloat/src/main/scala/MulRecFN.scala:113:26
    .io_in_isInf   (_mulRawFN_io_rawOut_isInf),	// hardfloat/src/main/scala/MulRecFN.scala:113:26
    .io_in_isZero  (_mulRawFN_io_rawOut_isZero),	// hardfloat/src/main/scala/MulRecFN.scala:113:26
    .io_in_sign    (_mulRawFN_io_rawOut_sign),	// hardfloat/src/main/scala/MulRecFN.scala:113:26
    .io_in_sExp    (_mulRawFN_io_rawOut_sExp),	// hardfloat/src/main/scala/MulRecFN.scala:113:26
    .io_in_sig     (_mulRawFN_io_rawOut_sig),	// hardfloat/src/main/scala/MulRecFN.scala:113:26
    .io_out        (io_out)
  );
endmodule

module Multiply(	// <stdin>:402:10, :1031:10, :1660:10
  input  [31:0] io_a,
  output [31:0] io_out);

  wire [32:0] _mul_io_out;	// src/main/scala/bsdf/Multiply.scala:20:19
  wire        mul_io_a_rawIn_isZeroExpIn = io_a[30:23] == 8'h0;	// hardfloat/src/main/scala/fNFromRecFN.scala:60:21, hardfloat/src/main/scala/rawFloatFromFN.scala:45:19, :48:30
  wire [4:0]  mul_io_a_rawIn_normDist =
    io_a[22]
      ? 5'h0
      : io_a[21]
          ? 5'h1
          : io_a[20]
              ? 5'h2
              : io_a[19]
                  ? 5'h3
                  : io_a[18]
                      ? 5'h4
                      : io_a[17]
                          ? 5'h5
                          : io_a[16]
                              ? 5'h6
                              : io_a[15]
                                  ? 5'h7
                                  : io_a[14]
                                      ? 5'h8
                                      : io_a[13]
                                          ? 5'h9
                                          : io_a[12]
                                              ? 5'hA
                                              : io_a[11]
                                                  ? 5'hB
                                                  : io_a[10]
                                                      ? 5'hC
                                                      : io_a[9]
                                                          ? 5'hD
                                                          : io_a[8]
                                                              ? 5'hE
                                                              : io_a[7]
                                                                  ? 5'hF
                                                                  : io_a[6]
                                                                      ? 5'h10
                                                                      : io_a[5]
                                                                          ? 5'h11
                                                                          : io_a[4]
                                                                              ? 5'h12
                                                                              : io_a[3]
                                                                                  ? 5'h13
                                                                                  : io_a[2]
                                                                                      ? 5'h14
                                                                                      : io_a[1]
                                                                                          ? 5'h15
                                                                                          : 5'h16;	// hardfloat/src/main/scala/primitives.scala:91:52, hardfloat/src/main/scala/rawFloatFromFN.scala:46:21, src/main/scala/chisel3/util/Mux.scala:50:70
  wire [53:0] _mul_io_a_rawIn_subnormFract_T =
    {31'h0, io_a[22:0]} << mul_io_a_rawIn_normDist;	// hardfloat/src/main/scala/rawFloatFromFN.scala:46:21, :52:33, src/main/scala/chisel3/util/Mux.scala:50:70
  wire [8:0]  mul_io_a_rawIn_adjustedExp =
    (mul_io_a_rawIn_isZeroExpIn ? {4'hF, ~mul_io_a_rawIn_normDist} : {1'h0, io_a[30:23]})
    + {7'h20, mul_io_a_rawIn_isZeroExpIn ? 2'h2 : 2'h1};	// hardfloat/src/main/scala/rawFloatFromFN.scala:45:19, :48:30, :54:10, :55:18, :57:9, :58:14, src/main/scala/chisel3/util/Mux.scala:50:70
  wire        io_out_rawIn_isInf = (&(_mul_io_out[31:30])) & ~(_mul_io_out[29]);	// hardfloat/src/main/scala/rawFloatFromRecFN.scala:51:21, :53:{28,53}, :56:41, :57:{33,36}, src/main/scala/bsdf/Multiply.scala:20:19
  wire        io_out_isSubnormal = $signed({1'h0, _mul_io_out[31:23]}) < 10'sh82;	// hardfloat/src/main/scala/fNFromRecFN.scala:51:38, hardfloat/src/main/scala/rawFloatFromFN.scala:48:30, hardfloat/src/main/scala/rawFloatFromRecFN.scala:51:21, :60:27, src/main/scala/bsdf/Multiply.scala:20:19
  wire [23:0] _io_out_denormFract_T_1 =
    {1'h0, |(_mul_io_out[31:29]), _mul_io_out[22:1]} >> 5'h1 - _mul_io_out[27:23];	// hardfloat/src/main/scala/fNFromRecFN.scala:52:{35,47}, :53:{38,42}, hardfloat/src/main/scala/rawFloatFromFN.scala:48:30, hardfloat/src/main/scala/rawFloatFromRecFN.scala:51:21, :52:{28,53}, src/main/scala/bsdf/Multiply.scala:20:19, src/main/scala/chisel3/util/Mux.scala:50:70
  MulRecFN mul (	// src/main/scala/bsdf/Multiply.scala:20:19
    .io_a
      ({io_a[31],
        (mul_io_a_rawIn_isZeroExpIn & ~(|(io_a[22:0]))
           ? 3'h0
           : mul_io_a_rawIn_adjustedExp[8:6])
          | {2'h0, (&(mul_io_a_rawIn_adjustedExp[8:7])) & (|(io_a[22:0]))},
        mul_io_a_rawIn_adjustedExp[5:0],
        mul_io_a_rawIn_isZeroExpIn
          ? {_mul_io_a_rawIn_subnormFract_T[21:0], 1'h0}
          : io_a[22:0]}),	// hardfloat/src/main/scala/rawFloatFromFN.scala:44:18, :46:21, :48:30, :49:34, :52:{33,46,64}, :57:9, :60:30, :61:{32,57}, :64:28, :70:33, hardfloat/src/main/scala/recFNFromFN.scala:48:{15,50,76}, :50:{23,41}
    .io_out (_mul_io_out)
  );
  assign io_out =
    {_mul_io_out[32],
     (io_out_isSubnormal ? 8'h0 : _mul_io_out[30:23] + 8'h7F)
       | {8{(&(_mul_io_out[31:30])) & _mul_io_out[29] | io_out_rawIn_isInf}},
     io_out_isSubnormal
       ? _io_out_denormFract_T_1[22:0]
       : io_out_rawIn_isInf ? 23'h0 : _mul_io_out[22:0]};	// <stdin>:402:10, :1031:10, :1660:10, hardfloat/src/main/scala/fNFromRecFN.scala:51:38, :53:{42,60}, :56:16, :58:{27,45}, :60:{15,21,44}, :62:16, :64:20, :66:12, hardfloat/src/main/scala/rawFloatFromRecFN.scala:51:21, :53:{28,53}, :56:{33,41}, :57:33, :59:25, :61:49, src/main/scala/bsdf/Multiply.scala:20:19
endmodule

module MultiplySpectrum(	// <stdin>:1890:10
  input  [31:0] io_a_values_0,
                io_a_values_1,
                io_a_values_2,
  output [31:0] io_out_values_0,
                io_out_values_1,
                io_out_values_2);

  Multiply multipliers_multiply (	// src/main/scala/bsdf/MultiplySpectrum.scala:17:26
    .io_a   (io_a_values_0),
    .io_out (io_out_values_0)
  );
  Multiply multipliers_multiply_1 (	// src/main/scala/bsdf/MultiplySpectrum.scala:17:26
    .io_a   (io_a_values_1),
    .io_out (io_out_values_1)
  );
  Multiply multipliers_multiply_2 (	// src/main/scala/bsdf/MultiplySpectrum.scala:17:26
    .io_a   (io_a_values_2),
    .io_out (io_out_values_2)
  );
endmodule

module Diffuse(	// <stdin>:1924:10
  input         clock,
                reset,
                input_valid,
  input  [31:0] input_bits_reflectance_values_0,
                input_bits_reflectance_values_1,
                input_bits_reflectance_values_2,
  input         output_ready,
  output        input_ready,
                output_valid,
  output [31:0] output_bits_out_values_0,
                output_bits_out_values_1,
                output_bits_out_values_2);

  reg         busy;	// src/main/scala/bsdf/Diffuse.scala:22:21
  reg         resultValid;	// src/main/scala/bsdf/Diffuse.scala:23:28
  reg  [31:0] reflectance_values_0;	// src/main/scala/bsdf/Diffuse.scala:24:24
  reg  [31:0] reflectance_values_1;	// src/main/scala/bsdf/Diffuse.scala:24:24
  reg  [31:0] reflectance_values_2;	// src/main/scala/bsdf/Diffuse.scala:24:24
  wire        _T = output_ready & resultValid;	// src/main/scala/bsdf/Diffuse.scala:23:28, :38:23
  always @(posedge clock) begin
    if (reset) begin
      busy <= 1'h0;	// src/main/scala/bsdf/Diffuse.scala:22:21
      resultValid <= 1'h0;	// src/main/scala/bsdf/Diffuse.scala:22:21, :23:28
    end
    else if (busy) begin	// src/main/scala/bsdf/Diffuse.scala:22:21
      busy <= ~_T & busy;	// src/main/scala/bsdf/Diffuse.scala:22:21, :38:{23,39}, :39:12
      resultValid <= ~_T;	// src/main/scala/bsdf/Diffuse.scala:22:21, :23:28, :38:{23,39}, :39:12
    end
    else	// src/main/scala/bsdf/Diffuse.scala:22:21
      busy <= input_valid | busy;	// src/main/scala/bsdf/Diffuse.scala:22:21, :43:23, :47:12
    if (busy | ~input_valid) begin	// src/main/scala/bsdf/Diffuse.scala:22:21, :24:24, :35:14, :43:23
    end
    else begin	// src/main/scala/bsdf/Diffuse.scala:24:24, :35:14, :43:23
      reflectance_values_0 <= input_bits_reflectance_values_0;	// src/main/scala/bsdf/Diffuse.scala:24:24
      reflectance_values_1 <= input_bits_reflectance_values_1;	// src/main/scala/bsdf/Diffuse.scala:24:24
      reflectance_values_2 <= input_bits_reflectance_values_2;	// src/main/scala/bsdf/Diffuse.scala:24:24
    end
  end // always @(posedge)
  `ifndef SYNTHESIS	// <stdin>:1924:10
    `ifdef FIRRTL_BEFORE_INITIAL	// <stdin>:1924:10
      `FIRRTL_BEFORE_INITIAL	// <stdin>:1924:10
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM_0;	// <stdin>:1924:10
    logic [31:0] _RANDOM_1;	// <stdin>:1924:10
    logic [31:0] _RANDOM_2;	// <stdin>:1924:10
    logic [31:0] _RANDOM_3;	// <stdin>:1924:10
    logic [31:0] _RANDOM_4;	// <stdin>:1924:10
    initial begin	// <stdin>:1924:10
      `ifdef INIT_RANDOM_PROLOG_	// <stdin>:1924:10
        `INIT_RANDOM_PROLOG_	// <stdin>:1924:10
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT	// <stdin>:1924:10
        _RANDOM_0 = `RANDOM;	// <stdin>:1924:10
        _RANDOM_1 = `RANDOM;	// <stdin>:1924:10
        _RANDOM_2 = `RANDOM;	// <stdin>:1924:10
        _RANDOM_3 = `RANDOM;	// <stdin>:1924:10
        _RANDOM_4 = `RANDOM;	// <stdin>:1924:10
        busy = _RANDOM_0[31];	// src/main/scala/bsdf/Diffuse.scala:22:21
        resultValid = _RANDOM_1[0];	// src/main/scala/bsdf/Diffuse.scala:23:28
        reflectance_values_0 = {_RANDOM_1[31:1], _RANDOM_2[0]};	// src/main/scala/bsdf/Diffuse.scala:23:28, :24:24
        reflectance_values_1 = {_RANDOM_2[31:1], _RANDOM_3[0]};	// src/main/scala/bsdf/Diffuse.scala:24:24
        reflectance_values_2 = {_RANDOM_3[31:1], _RANDOM_4[0]};	// src/main/scala/bsdf/Diffuse.scala:24:24
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL	// <stdin>:1924:10
      `FIRRTL_AFTER_INITIAL	// <stdin>:1924:10
    `endif // FIRRTL_AFTER_INITIAL
  `endif // not def SYNTHESIS
  MultiplySpectrum multiply (	// src/main/scala/bsdf/Diffuse.scala:19:24
    .io_a_values_0   (reflectance_values_0),	// src/main/scala/bsdf/Diffuse.scala:24:24
    .io_a_values_1   (reflectance_values_1),	// src/main/scala/bsdf/Diffuse.scala:24:24
    .io_a_values_2   (reflectance_values_2),	// src/main/scala/bsdf/Diffuse.scala:24:24
    .io_out_values_0 (output_bits_out_values_0),
    .io_out_values_1 (output_bits_out_values_1),
    .io_out_values_2 (output_bits_out_values_2)
  );
  assign input_ready = ~busy & input_valid | ~busy;	// <stdin>:1924:10, src/main/scala/bsdf/Diffuse.scala:22:21, :26:{15,18}, :35:14, :43:23
  assign output_valid = resultValid;	// <stdin>:1924:10, src/main/scala/bsdf/Diffuse.scala:23:28
endmodule
// gonsolo: End Diffuse.v

`default_nettype none

// Keep in sync with dv/cocotb/pepe/pepe.py
`define DIFFERENCE	5 // The first five bits are used by caravel
`define WRITE		28 - `DIFFERENCE
`define SELECT1		27 - `DIFFERENCE
`define SELECT2		26 - `DIFFERENCE
`define INPUT7		25 - `DIFFERENCE
`define INPUT6		`INPUT7 - 1
`define INPUT5		`INPUT7 - 2
`define INPUT4		`INPUT7 - 3
`define INPUT3		`INPUT7 - 4
`define INPUT2		`INPUT7 - 5
`define INPUT1		`INPUT7 - 6
`define INPUT0		`INPUT7 - 7
`define OUTPUT7		12 - `DIFFERENCE
`define OUTPUT0		`OUTPUT7 - 7


module user_proj_example #(
    parameter BITS = 24
)(
`ifdef USE_POWER_PINS
    inout vdd,
    inout vss,
`endif

    input wb_clk_i,
    input wb_rst_i,

    // IOs
    input  [BITS-1:0] io_in,
    output [BITS-1:0] io_out,
    output [BITS-1:0] io_oeb,

    // IRQ
    output [2:0] irq
);

    wire clock = wb_clk_i;
    wire reset = wb_rst_i;

    assign io_oeb = 24'h0000FF;
    assign irq = 3'b000;	// Unused

    reg [7:0] channel0_byte0, channel0_byte1, channel0_byte2, channel0_byte3;
    reg [7:0] channel1_byte0, channel1_byte1, channel1_byte2, channel1_byte3;
    reg [7:0] channel2_byte0, channel2_byte1, channel2_byte2, channel2_byte3;
    reg [7:0] out_byte;

    initial begin
        channel0_byte0 = 8'h00;
        channel0_byte1 = 8'h00;
        channel0_byte2 = 8'h00;
        channel0_byte3 = 8'h00;
        channel1_byte0 = 8'h00;
        channel1_byte1 = 8'h00;
        channel1_byte2 = 8'h00;
        channel1_byte3 = 8'h00;
        channel2_byte0 = 8'h00;
        channel2_byte1 = 8'h00;
        channel2_byte2 = 8'h00;
        channel2_byte3 = 8'h00;
        out_byte = 8'h00;
    end

    wire [31:0] input_bits_reflectance_values_0 = { channel0_byte0, channel0_byte1, channel0_byte2, channel0_byte3 };
    wire [31:0] input_bits_reflectance_values_1 = { channel1_byte0, channel1_byte1, channel1_byte2, channel1_byte3 };
    wire [31:0] input_bits_reflectance_values_2 = { channel2_byte0, channel2_byte1, channel2_byte2, channel2_byte3 };
    wire input_valid = 1;
    wire input_ready;		// Unused
    wire output_ready = 1;
    wire output_valid;		// Unused
    wire [31:0] output_bits_out_values_0;
    wire [31:0] output_bits_out_values_1;
    wire [31:0] output_bits_out_values_2;

    // WRITE = 28
    wire input_set = io_in[`WRITE];
    wire [1:0] byte_select = io_in[`SELECT1:`SELECT2];
    wire [7:0] input_byte = io_in[`INPUT7:`INPUT0];

    wire _unused_ok = &{
        1'b0,
	io_in[12:0],
        input_ready,
        output_valid,
	output_bits_out_values_1,
	output_bits_out_values_2,
        1'b0
    };

    Diffuse diffuse(
        .clock(clock),
        .reset(reset),
        .input_valid(input_valid),
        .input_ready(input_ready),
        .input_bits_reflectance_values_0(input_bits_reflectance_values_0),
        .input_bits_reflectance_values_1(input_bits_reflectance_values_1),
        .input_bits_reflectance_values_2(input_bits_reflectance_values_2),
        .output_valid(output_valid),
        .output_ready(output_ready),
        .output_bits_out_values_0(output_bits_out_values_0),
        .output_bits_out_values_1(output_bits_out_values_1),
        .output_bits_out_values_2(output_bits_out_values_2)
    );

    always @(posedge clock) begin
	// TODO: channel 1 and 2
	if (input_set) begin
		case(byte_select)
			2'b11: channel0_byte0 <= input_byte;
			2'b10: channel0_byte1 <= input_byte;
			2'b01: channel0_byte2 <= input_byte;
			2'b00: channel0_byte3 <= input_byte;
		endcase
	end else begin
		case(byte_select)
			2'b11: out_byte <= output_bits_out_values_0[31:24];
			2'b10: out_byte <= output_bits_out_values_0[23:16];
			2'b01: out_byte <= output_bits_out_values_0[15:8];
			2'b00: out_byte <= output_bits_out_values_0[7:0];
		endcase
	end
    end

    assign io_out = { 16'h0, out_byte };

endmodule

`default_nettype wire
